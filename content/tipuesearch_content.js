var tipuesearch = {"pages": [{'title': 'About', 'text': '設計二甲\xa0 \xa0許耀中 \n 我的頻道:\xa0 youtube \n 倉儲\xa0:\xa0 Cad2020 \n 小組網站 \n 小組倉儲 \n \n', 'tags': '', 'url': 'About.html'}, {'title': '課程內容', 'text': '', 'tags': '', 'url': '課程內容.html'}, {'title': '課程筆記', 'text': '', 'tags': '', 'url': '課程筆記.html'}, {'title': '指令', 'text': 'git config --global http.proxy  http:// {2001:288:6004:17::69}:3128 (中華電信的 proxy) \n git config --global user.email "使用者的email" \n git config --global user.name "40823111(使用者名稱)" \n git clone  https://git hub.com/40823111/cad2020.git (把github上的資料複製到cad2020\xa0 的資料夾) \n git submodule add\xa0  https://git hub.com/mdecourse/cmsimde.git cmsimde\xa0 \n git clone --recurse submodules  https://git hub.com/40823111/cad2020.git \n pip install\xa0 flask flask_cors lxml bs4 markdown pelican leo (安裝軟件) \n tracert\xa0 \xa0 是一種電腦網路工具。它可顯示封包在IP網路經過的路由器的IP位址 \n trace route\xa0 \xa0 執行路由追蹤可以協助您確認網路連線問題的地方 \xa0 \n nslookup( name server lookup )\xa0 查詢域名對應的IP位址 \n ipconfig /all\xa0 \xa0\xa0 控制網路連線的一個命令列工具 \n <font size="5">指定字體大小為5</font>\xa0 放大字體 \n pip install flask flask_cors lxml bs4 markdown pelican leo\xa0 \n <pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false"></pre>c\xa0\xa0 \n 上傳 \n 到你的cad2020 \n git add . \n git commit -m "你丄傳的檔案名稱" \n git push \n', 'tags': '', 'url': '指令.html'}, {'title': '單字翻譯', 'text': 'recurse 遞迴\xa0 \xa0  \n \n \xa0 \n', 'tags': '', 'url': '單字翻譯.html'}, {'title': 'W1', 'text': '\n', 'tags': '', 'url': 'W1.html'}, {'title': '建網頁', 'text': '怎麼興建網站 \n (1)下載 fall2020_cp.7 壓縮檔\xa0 \xa0解壓縮到我的隨身系統(USB) \n (2)下載  Portable GIT. \xa0解壓縮並放入DATA中的PortableGit資料夾中 \n \n (3) 修改Start的路進 \n \n (4)到github 新建一個repository(資料庫)\xa0 名子為cad2020\xa0 \n \n (5) 到github網站git clone自己倉儲的網址clone完後git submodule add \n \n (6)進入cmsimde\xa0 把up_dir裡的東西全部複製 \n \n (7)放到cmsimde外面\xa0 cad2020的目錄下 \n \xa0 \n \xa0 (8)進入cmsimde目錄下\xa0 \xa0將wsgi.py拖入SciTE\xa0 \xa0 \xa0tools-->go \n \n (9)如果成功了 記得\xa0 git push 才能把網頁推上去 不然會顯示不出來!!!\xa0 \n \n', 'tags': '', 'url': '建網頁.html'}, {'title': 'pdf1 體積', 'text': '使用\xa0 soildworks2017\xa0 inventer2017 畫出零件檔和標示體積\xa0 \n 圖檔:\xa0 Solidworks 零件繪圖練習1.pdf \n \n \n \n \n \n \n \n Inventor \n \n', 'tags': '', 'url': 'pdf1 體積.html'}, {'title': 'w2', 'text': '123 \n', 'tags': '', 'url': 'w2.html'}, {'title': '影片(pdf1)', 'text': 'PDF1 soildworks 和 inventer 的影片 \n 圖檔:  Solidworks 零件繪圖練習1.pdf \n \xa041 題 \n \n \n 42 題 \n \n 43 題 \n \n 44 題 \n \n \n 45 題 \n \n 46 題 \n \n 47 題 \n \n 48 題 \n \n 49 題 \n \n 50\xa0 題 \n \n', 'tags': '', 'url': '影片(pdf1).html'}, {'title': '影片(pdf2)', 'text': 'PDF2 soildworks 和 inventer 的影片 \n 圖檔:\xa0 Solidworks 零件繪圖練習2.pdf \n \n \n', 'tags': '', 'url': '影片(pdf2).html'}, {'title': 'W3', 'text': '中秋節 \n \n', 'tags': '', 'url': 'W3.html'}, {'title': 'W4', 'text': '', 'tags': '', 'url': 'W4.html'}, {'title': 'SSH', 'text': '\n 如何興建  SSH \n', 'tags': '', 'url': 'SSH.html'}, {'title': '如何使用 wink 3', 'text': '(1) 先下載 \xa0 Wink3.7 \n (2) wink 3 的介紹影片 \n \n \n (3)\xa0wink 3 的快捷鍵 \n \xa0 \xa0 \xa0截圖\xa0 Pause\xa0 \xa0開始/結束 Shift+ Pause \n \n \n \n', 'tags': '', 'url': '如何使用 wink 3.html'}, {'title': '心得', 'text': '\n', 'tags': '', 'url': '心得.html'}, {'title': 'w5', 'text': 'SoildWorks Api \n API為Application Program Interface英文縮寫, 意為應用編程接口 \n SOLIDWORKS應用程序編程接口（API）是SOLIDWORKS軟件的COM編程接口。 \n 和操作使用軟件本身的功能一樣，屬於應用手法的一種。一般的操作是：通過鼠標點擊，鍵盤鍵入數字操作它現有的按鈕，命令；而API 則是通過編程語言代碼，對現有的功能進行一定的控制，形成新的命令或功能，即利用編程代碼來操控軟件的現有功能 \n 該API包含數百種函數，您可以從Visual Basic（VB），Visual Basic for Applications（VBA），VB.NET，C ++，C＃或SOLIDWORKS宏文件中調用。 \n \n \n \n', 'tags': '', 'url': 'w5.html'}, {'title': 'w6', 'text': '\n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '', 'tags': '', 'url': 'w7.html'}, {'title': 'Engineering(工程師)', 'text': 'Engineers, as practitioners of engineering, are professionals who invent, design, analyze, build and test machines, complex systems, structures, gadgets and materials to fulfill functional objectives and requirements while considering the limitations imposed by practicality, regulation, safety and cost. \n \n', 'tags': '', 'url': 'Engineering(工程師).html'}, {'title': '利用 SciTE 編輯器類解譯 ANSI C 程式', 'text': '下載\xa0 tcc-0.9.27-win64-bin.zip \n 解壓縮放入 y:\\ 根目錄中\xa0 \n 2. 接著將 y:\\tcc\\ 放入隨身系統中的 path 命令搜尋路徑中, 一旦啟動後就可以直接執行 tcc.exe, 也就是 start.bat 修改的地方 \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n set path_portablegit=%Disk%:\\Portablegit\\bin; \n set path_julia=%Disk%:\\julia-1.5.2\\bin; \n set path_tcc=%Disk%:\\tcc\\; \n \xa0 \n path=%Disk%:;%path_python%;%path_portablegit%;%path_julia%;%path_tcc%;%path%; \n \n \n \n \n \n 3. 修改完記得關掉重開 start.bat \n 4. 再重新打開start.bat 並輸入tcc \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n \n \n \n Tiny C Compiler 0.9.27 - Copyright (C) 2001-2006 Fabrice Bellard \n Usage: tcc [options...] [-o outfile] [-c] infile(s)... \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0 tcc [options...] -run infile [arguments...] \n General options: \n \xa0\xa0 -c\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 compile only - generate an object file \n \xa0\xa0 -o outfile\xa0 set output filename \n \xa0\xa0 -run\xa0\xa0\xa0\xa0\xa0\xa0\xa0 run compiled source \n \xa0\xa0 -fflag\xa0\xa0\xa0\xa0\xa0 set or reset ( with   \'no-\'   prefix)  \'flag\'   (see tcc -hh) \n \xa0\xa0 -Wwarning\xa0\xa0 set or reset ( with   \'no-\'   prefix)  \'warning\'   (see tcc -hh) \n \xa0\xa0 -w\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 disable all warnings \n \xa0\xa0 -v -vv\xa0\xa0\xa0\xa0\xa0 show version, show search paths or loaded files \n \xa0\xa0 -h -hh\xa0\xa0\xa0\xa0\xa0 show  this , show more help \n \xa0\xa0 -bench\xa0\xa0\xa0\xa0\xa0 show compilation statistics \n \xa0\xa0 -\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 use stdin pipe as infile \n \xa0\xa0 @listfile\xa0\xa0 read arguments from listfile \n Preprocessor options: \n \xa0\xa0 -Idir\xa0\xa0\xa0\xa0\xa0\xa0 add include path  \'dir\' \n \xa0\xa0 -Dsym[=val] define  \'sym\'   with   value  \'val\' \n \xa0\xa0 -Usym\xa0\xa0\xa0\xa0\xa0\xa0 undefine  \'sym\' \n \xa0\xa0 -E\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 preprocess only \n Linker options: \n \xa0\xa0 -Ldir\xa0\xa0\xa0\xa0\xa0\xa0 add library path  \'dir\' \n \xa0\xa0 -llib\xa0\xa0\xa0\xa0\xa0\xa0 link  with   dynamic or static library  \'lib\' \n \xa0\xa0 -r\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 generate (relocatable) object file \n \xa0\xa0 -shared\xa0\xa0\xa0\xa0 generate a shared library/dll \n \xa0\xa0 -rdynamic\xa0\xa0 export all global symbols to dynamic linker \n \xa0\xa0 -soname\xa0\xa0\xa0\xa0 set name  for   shared library to be used at runtime \n \xa0\xa0 -Wl,-opt[=val]\xa0 set linker option (see tcc -hh) \n Debugger options: \n \xa0\xa0 -g\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 generate runtime debug info \n \xa0\xa0 -b\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 compile  with   built- in   memory and bounds checker (implies -g) \n \xa0\xa0 -bt N\xa0\xa0\xa0\xa0\xa0\xa0 show N callers  in   stack traces \n Misc. options: \n \xa0\xa0 -x[c|a|n]\xa0\xa0 specify type of the next infile \n \xa0\xa0 -nostdinc\xa0\xa0  do   not use standard system include paths \n \xa0\xa0 -nostdlib\xa0\xa0  do   not link  with   standard crt and libraries \n \xa0\xa0 -Bdir\xa0\xa0\xa0\xa0\xa0\xa0 set tcc\'s private include/library dir \n \xa0\xa0 -MD\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 generate dependency file  for   make \n \xa0\xa0 -MF file\xa0\xa0\xa0 specify dependency file name \n \xa0\xa0 -m32/64\xa0\xa0\xa0\xa0 defer to i386/x86_64 cross compiler \n Tools: \n \xa0\xa0 create library\xa0 : tcc -ar [rcsv] lib.a files \n \xa0\xa0 create def file : tcc -impdef lib.dll [-v] [-o lib.def] \n \n \n \n \n \n 表示已經啟動路徑\xa0 y:\\tcc 目錄. \n 3. 接下來必須修改 SciTE 編輯器中的 cpp.properties, 讓 Tools -> Go 可以呼叫 tcc.exe 中副檔名為 .c 的程式 \n 4.把 SciTE 的工能表 Options 往下點擊 Open cpp.properties 編輯設定檔案, 並且勾選 View -> Line Number 在編輯器中顯示行號, 針對\xa0 476 行的設定進行修改: \n #紅色的地方(註解掉)\xa0 \xa0#黃色的地方(增加上去)\xa0 \n \n 意即, 將原先 cc=g++ 與 ccc=gcc 改為利用 y:\\tcc\\tcc.exe -run 進行類解譯, 而且將原先必須經過編譯後以檔名執行的 command.go.*.c 設為直接利用 tcc.exe -run ex.c 的方式執行, 而 FileNameExt 就是帶有副檔名的程式名稱. \n 5. 完成設定後, 可以在編輯器中加入 hello.c (記得先存檔), 並且利用 Tools -> Go 直接執行. \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n #include <stdio.h> \n \xa0 \xa0 \n int   main() { \n \xa0\xa0\xa0\xa0 printf ( "Hello, world!\\n" ); \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n \n \n \n 6. 練習2 \n 7.首先 下載\xa0 gnuplot.7z \xa0 與 \xa0 wqy-microhei.ttc \n 8. gunplot 目錄與 .ttc 中文字型檔案可以放在 y:\\, 並且在 start.bat 加入 y:\\gnuplot\\bin  \n #紅色(增加上去) \n \n 9. 完成所有步驟後, 可以執行下面的程式 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n \n \n \n /* Runge Kutta for a set of first order differential equations */ \n \xa0 \xa0 \n #include <stdio.h> \n #include <math.h> \n \xa0 \xa0 \n #define N 2 /* number of first order equations */ \n #define dist 0.1 /* stepsize in t*/ \n #define MAX 30.0 /* max for t */ \n \xa0 \xa0 \n FILE   *output;  /* internal filename */ \n FILE   *output1;  /* internal filename */ \n // 利用 pipe 呼叫 gnuplot 繪圖 \n FILE   *pipe; \n \xa0 \xa0 \n void   runge4( double   x,  double   y[],  double   step);  /* Runge-Kutta function */ \n double   f( double   x,  double   y[],  int   i);  /* function for derivatives */ \n \xa0 \xa0 \n void   main(){ \n \xa0 \xa0 \n \xa0\xa0 double   t, y[N]; \n \xa0\xa0 int   j; \n \xa0 \xa0 \n \xa0\xa0 output= fopen ( "osc.dat" ,  "w" );  /* external filename */ \n \xa0\xa0 output1= fopen ( "osc1.dat" ,  "w" );  /* external filename */ \n \xa0 \xa0 \n \xa0\xa0 y[0]=1.0;  /* initial position */ \n \xa0\xa0 y[1]=0.0;  /* initial velocity */ \n \xa0 \xa0 \n \xa0\xa0 //fprintf(output, "0\\t%f\\n", y[0]); \n \xa0 \xa0 \n \xa0\xa0 for   (j=1; j*dist<=MAX ;j++)  /* time loop */ { \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 t=j*dist; \n \xa0\xa0\xa0\xa0 runge4(t, y, dist); \n \xa0\xa0\xa0\xa0 fprintf (output,  "%f\\t%f\\n" , t, y[0]); \n \xa0\xa0\xa0\xa0 fprintf (output1,  "%f\\t%f\\n" , t, y[1]); \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 fclose (output); \n \xa0\xa0 fclose (output1); \n \xa0 \xa0 \n \xa0\xa0 pipe = popen( "gnuplot -persist" , "w" ); \n \xa0\xa0 //fprintf(pipe,"set term png enhanced font \\"v:/fireflysung.ttf\\" 18 \\n"); \n \xa0\xa0 fprintf (pipe, "set term png enhanced font \\"y:/wqy-microhei.ttc\\" 18 \\n" ); \n \xa0\xa0 //fprintf(pipe,"set yrange [68:70]\\n"); \n \xa0\xa0 fprintf (pipe, "set output \\"test.png\\"\\n" ); \n \xa0\xa0 fprintf (pipe,  "plot \\"osc.dat\\" title \\"位移\\" with lines, \\"osc1.dat\\" title \\"速度\\" with lines\\n" ); \n \xa0\xa0 fprintf (pipe, "quit\\n" ); \n \xa0 \n \xa0\xa0 fprintf (pipe, "quit\\n" ); \n \xa0\xa0 pclose(pipe); \n } \n \xa0 \xa0 \n void   runge4( double   x,  double   y[],  double   step){ \n \xa0 \xa0 \n \xa0\xa0 double   h=step/2.0,  /* the midpoint */ \n \xa0\xa0 t1[N], t2[N], t3[N],  /* temporary storage arrays */ \n \xa0\xa0 k1[N], k2[N], k3[N],k4[N];  /* for Runge-Kutta */ \n \xa0\xa0 int   i; \n \xa0 \xa0 \n \xa0\xa0 for   (i=0;i<N;i++){ \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 t1[i]=y[i]+0.5*(k1[i]=step*f(x,y,i)); \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 for   (i=0;i<N;i++){ \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 t2[i]=y[i]+0.5*(k2[i]=step*f(x+h, t1, i)); \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 for   (i=0;i<N;i++){ \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 t3[i]=y[i]+ (k3[i]=step*f(x+h, t2, i)); \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 for   (i=0;i<N;i++){ \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 k4[i]= step*f(x+step, t3, i); \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 for   (i=0;i<N;i++){ \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 y[i]+=(k1[i]+2*k2[i]+2*k3[i]+k4[i])/6.0; \n \xa0\xa0 } \n } \n \xa0 \xa0 \n double   f( double   x,  double   y[],  int   i){ \n \xa0 \xa0 \n \xa0\xa0 if   (i==0) \n \xa0\xa0\xa0\xa0 x=y[1];  /* derivative of first equation */ \n \xa0\xa0 if   (i==1) \n \xa0\xa0\xa0\xa0 x=-y[0]-0.5*y[1]; \n \xa0\xa0 return   x; \n } \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '利用 SciTE 編輯器類解譯 ANSI C 程式.html'}]};